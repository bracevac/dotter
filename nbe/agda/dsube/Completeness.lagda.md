# Completeness of Normalization by Evaluation for D·µâ<:>

We prove completeness with a partial equivalence (PER) model.
Completeness means that whatever terms are Œ≤Œ∑-equal in the D·µâ<:> system,
so will be their normal forms in the PER model of equality (and their NFs exist!)

It is sufficient to use this result to conclude termination of NbE,
for the special case of relating a well-typed expression to itself.


```agda
module dsube.Completeness where

open import Data.Bool using (true; false)
open import Data.Product using (Œ£; ‚àÉ; Œ£-syntax; ‚àÉ-syntax; _√ó_) renaming (_,_ to ‚ü®_,_‚ü©)
open Œ£
open import Data.Sum using (_‚äé_; inj‚ÇÅ; inj‚ÇÇ)
open import Function using (_‚àò_; id)
open import Data.Empty using (‚ä• ; ‚ä•-elim)
open import Data.Unit using (‚ä§; tt)
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_‚â°_; refl)
open import Data.Nat using (‚Ñï; zero; suc; _‚â§‚Ä≤_; _<‚Ä≤_)
open import Agda.Primitive using (lzero; lsuc; Level) renaming (_‚äî_ to _‚äîÀ°_)
open import dsube.Syntax
open import dsube.NbE
open import dsube.Relations
open import dsube.RelFun
open import dsube.PER
open import dsube.Universes
-- TODO should the below things be automatically exported?
open Per {{...}}
open Œ†-‚ü®_,_‚ü© {{...}}
open [_‚àô_]‚àà_
open [_==_‚àô_==_]‚àà_
open Rel-family {{...}}
open _‚â§‚Ä≤_
```
# Type Interpretation

For clarity, we alias the cumulative universe of PERs on our domain:
```agda
ùì£ùîÇùìπùìÆ = ùì¢ùìÆùìΩœâ
```
Then, we define the partial type interpretation function (again using Bove's graph encoding), which
is the composition of evaluation ‚ü¶_‚üß and interpretation ùìîùìµœâ into ùì£ùîÇùìπùìÆ:
```agda
data ‚ü¶_‚üß·µó ∏_‚áì_ : Exp ‚Üí Env ‚Üí Rel ‚Üí Set where
  ty-interp : ‚àÄ {T œÅ ùëá} ‚Üí
      ‚ü¶ T ‚üß œÅ ‚áì ùëá ‚Üí
      (UT : ùì§œâ ùëá) ‚Üí
      -----------------
      ‚ü¶ T ‚üß·µó ∏ œÅ ‚áì (ùìîùìµœâ UT)
```
The graph encoding is a function:
```agda
det-‚ü¶-‚üß·µó ∏ : ‚àÄ{T œÅ R R'} ‚Üí ‚ü¶ T ‚üß·µó ∏ œÅ ‚áì R ‚Üí ‚ü¶ T ‚üß·µó ∏ œÅ ‚áì R' ‚Üí R ‚â°·¥ø R'
det-‚ü¶-‚üß·µó ∏ (ty-interp x UT) (ty-interp x‚ÇÅ UT‚ÇÅ) rewrite det-‚ü¶-‚üß x x‚ÇÅ = ùìîùìµœâ-unif UT UT‚ÇÅ
```
# Logical Relation(s)

For each syntaxtic judgment form, we define its semantic counterpart.

```agda
-- what follows are some aux. record types, to avoid working with bare products and existentials in proofs

-- ‚ü¶ T ‚áì œÅ == T ‚áì œÅ' ‚üß·µó ∏ ‚Üî ‚àÉ[ ùëá ] ‚àÉ[ ùëá' ](ùëá == ùëá' ‚àà ùì£ùîÇùìπùìÆ √ó ‚ü¶ T ‚üß œÅ ‚áì ùëá √ó ‚ü¶ T ‚üß œÅ' ‚áì ùëá'))
record ‚ü¶_‚áì_==_‚áì_‚üß·µó ∏ (T : Exp) (œÅ : Env) (T' : Exp) (œÅ' : Env)  : Set where
  eta-equality
  constructor ‚ü¶ty_‚üß
  field
    {{ty-l}}  : ùïç
    {{ty-r}}  : ùïç
    {{ty-l-eval}} : ‚ü¶ T  ‚üß œÅ  ‚áì ty-l
    {{ty-r-eval}} : ‚ü¶ T' ‚üß œÅ' ‚áì ty-r
    ty-rel    : ùì£ùîÇùìπùìÆ ty-l ty-r
open ‚ü¶_‚áì_==_‚áì_‚üß·µó ∏

-- ‚ü¶ e ‚áì œÅ == e' ‚áì œÅ' ‚àà T ‚üß·µâÀ£·µñ ‚Üî ‚àÉ[ ùëí ] ‚àÉ[ ùëí' ] ‚àÉ[ R ](ùëí == ùëí' ‚àà R √ó ‚ü¶ e ‚üß œÅ ‚áì ùëí √ó ‚ü¶ e' ‚üß œÅ' ‚áì ùëí' √ó ‚ü¶ T ‚üß·µó ∏ œÅ ‚áì R)
record ‚ü¶_‚áì_==_‚áì_‚àà_‚üß·µâÀ£·µñ (e : Exp) (œÅ : Env) (e' : Exp) (œÅ' : Env) (T : Exp) : Set‚ÇÅ where
  eta-equality
  constructor ‚ü¶exp_,_‚üß
  field
    {{exp-l}}  : ùïç
    {{exp-r}}  : ùïç
    {exp-R}  : Rel
    {{exp-l-eval}} : ‚ü¶ e  ‚üß œÅ  ‚áì exp-l
    {{exp-r-eval}} : ‚ü¶ e' ‚üß œÅ' ‚áì exp-r
    exp-R-eval : ‚ü¶ T  ‚üß·µó ∏ œÅ ‚áì exp-R
    exp-rel    : exp-l == exp-r ‚àà exp-R
open ‚ü¶_‚áì_==_‚áì_‚àà_‚üß·µâÀ£·µñ


-- valid contexts and induced environment relation
data ‚ü¶_‚üß·∂ú·µóÀ£ : Ctx ‚Üí Env ‚Üí Env ‚Üí Set‚ÇÅ where -- TODO eventually, make the a == b ‚àà R notation work for this kind of binary relation
  ‚ü¶-‚üß·∂ú·µóÀ£-‚àÖ :
    ----------
    ‚ü¶ ‚àÖ ‚üß·∂ú·µóÀ£ Œµ Œµ

  ‚ü¶-‚üß·∂ú·µóÀ£-, : ‚àÄ{Œì T œÅ œÅ' ùëé ùëé' R} ‚Üí
    ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí
    ‚ü¶ T ‚üß·µó ∏ œÅ ‚áì R ‚Üí
    R ùëé ùëé' ‚Üí
    ------------------------------
    ‚ü¶ Œì , T ‚üß·∂ú·µóÀ£ (œÅ ,, ùëé) (œÅ' ,, ùëé')

-- ‚ü¶ œÉ == œÉ' ‚àà Œî ‚üßÀ¢·µò·µá ‚Üî ‚àÉ[ Œ¥ ] ‚àÉ[ Œ¥' ] (‚ü¶ Œî ‚üß·∂ú·µóÀ£ Œ¥ Œ¥' √ó ‚ü¶ œÉ ‚üßÀ¢ œÅ ‚áì Œ¥ √ó ‚ü¶ œÉ' ‚üßÀ¢ œÅ' ‚áì Œ¥'))
record ‚ü¶_‚áì_==_‚áì_‚àà_‚üßÀ¢·µò·µá (œÉ : Subst) (œÅ : Env) (œÉ' : Subst) (œÅ' : Env) (Œî : Ctx) : Set‚ÇÅ where
  eta-equality
  constructor ‚ü¶sub_‚üß
  field
    {sub-l}  : Env
    {sub-r}  : Env
    {{sub-l-eval}} : ‚ü¶ œÉ ‚üßÀ¢ œÅ ‚áì sub-l
    {{sub-r-eval}} : ‚ü¶ œÉ' ‚üßÀ¢ œÅ' ‚áì sub-r
    sub-rel    : ‚ü¶ Œî ‚üß·∂ú·µóÀ£ sub-l sub-r
open ‚ü¶_‚áì_==_‚áì_‚àà_‚üßÀ¢·µò·µá


-- valid contexts
data ‚ä®·∂ú·µóÀ£ : Ctx ‚Üí Set‚ÇÅ where
  ‚ä®-‚àÖ :
    ---
    ‚ä®·∂ú·µóÀ£ ‚àÖ

  ‚ä®-, : ‚àÄ{Œì T} ‚Üí
    {{‚ä®·∂ú·µóÀ£ Œì}} ‚Üí
    (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ T ‚áì œÅ == T ‚áì œÅ' ‚üß·µó ∏) ‚Üí
    ------------------------------------------------------------------
    ‚ä®·∂ú·µóÀ£ (Œì , T)

-- Valid types, we deviate from the thesis by inlining and simplifying the definition, which is Œì ‚ä®·µâÀ£·µñ T ‚à∂ Set k for some k.
-- Otherwise, we arrive at a non-wellfounded group of definitions which Agda rightfully rejects.
-- It (perhaps unsurprisingly) turns out this is just the extension ‚ä®-, case for valid contexts  ‚ä®·∂ú·µóÀ£ above.

-- Œì ‚ä®·µó ∏ T = ‚ä®·∂ú·µóÀ£ Œì √ó (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ T ‚áì œÅ == T ‚áì œÅ' ‚üß·µó ∏)
data _‚ä®·µó ∏_ : Ctx ‚Üí Exp ‚Üí Set‚ÇÅ where
  ‚ä®ty : ‚àÄ {Œì T} ‚Üí
    {{‚ä®·∂ú·µóÀ£ Œì}} ‚Üí
    (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ T ‚áì œÅ == T ‚áì œÅ' ‚üß·µó ∏) ‚Üí
    ------------------------------------------------
    Œì ‚ä®·µó ∏ T

-- equality
-- Œì ‚ä® e ‚âà e' ‚à∂ T = Œì ‚ä®·µó ∏ T √ó (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ e ‚áì œÅ == e' ‚áì œÅ' ‚àà T ‚üß·µâÀ£·µñ)
data _‚ä®_‚âà_‚à∂_ : Ctx ‚Üí Exp ‚Üí Exp ‚Üí Exp ‚Üí Set‚ÇÅ where
 ‚ä®‚âà : ‚àÄ{Œì e e' T} ‚Üí
    Œì ‚ä®·µó ∏ T ‚Üí
    (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ e ‚áì œÅ == e' ‚áì œÅ' ‚àà T ‚üß·µâÀ£·µñ) ‚Üí
    -------------------------------------------------------
    Œì ‚ä® e ‚âà e' ‚à∂ T

-- valid expressions
_‚ä®·µâÀ£·µñ_‚à∂_ : Ctx ‚Üí Exp ‚Üí Exp ‚Üí Set‚ÇÅ
Œì ‚ä®·µâÀ£·µñ e ‚à∂ T = Œì ‚ä® e ‚âà e ‚à∂ T

-- substitution equality
-- Œì ‚ä®À¢·µò·µá‚âà œÉ ‚âà œÉ' ‚à∂ Œî = ‚ä®·∂ú·µóÀ£ Œì √ó ‚ä®·∂ú·µóÀ£ Œî √ó (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ œÉ ‚áì œÅ == œÉ' ‚áì œÅ' ‚àà Œî ‚üßÀ¢·µò·µá)
data _‚ä®À¢·µò·µá‚âà_‚âà_‚à∂_ : Ctx ‚Üí Subst ‚Üí Subst ‚Üí Ctx ‚Üí Set‚ÇÅ where
  ‚ä®sub‚âà : ‚àÄ {Œì œÉ œÉ' Œî} ‚Üí
    {{‚ä®·∂ú·µóÀ£ Œì}} ‚Üí
    {{‚ä®·∂ú·µóÀ£ Œî}} ‚Üí
    (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ œÉ ‚áì œÅ == œÉ' ‚áì œÅ' ‚àà Œî ‚üßÀ¢·µò·µá) ‚Üí
    ------------------------------------------------------
    Œì ‚ä®À¢·µò·µá‚âà œÉ ‚âà œÉ' ‚à∂ Œî

-- valid substitutions
_‚ä®À¢·µò·µá_‚à∂_  : Ctx ‚Üí Subst ‚Üí Ctx ‚Üí Set‚ÇÅ
Œì ‚ä®À¢·µò·µá œÉ ‚à∂ Œî = Œì ‚ä®À¢·µò·µá‚âà œÉ ‚âà œÉ ‚à∂ Œî

-- TODO subtyping
_‚ä®_<‚à∂_ :  Ctx ‚Üí Exp ‚Üí Exp ‚Üí Set‚ÇÅ
Œì ‚ä® T <‚à∂ T' = {!!}

infix 3 _‚ä®·µó ∏_
infix 4 _‚ä®·µâÀ£·µñ_‚à∂_
infix 5 _‚ä®_‚âà_‚à∂_
infix 4 _‚ä®À¢·µò·µá_‚à∂_
infix 5 _‚ä®À¢·µò·µá‚âà_‚âà_‚à∂_
infix 4 _‚ä®_<‚à∂_
```
# Fundamental Theorem(s)

TODO: put into separate module
```agda
‚ä¢‚Üí‚ä®·∂ú·µóÀ£    : ‚àÄ {Œì}        ‚Üí ‚ä¢·∂ú·µóÀ£ Œì            ‚Üí ‚ä®·∂ú·µóÀ£ Œì
‚ä¢‚Üí‚ä®·µó ∏     : ‚àÄ {Œì T}      ‚Üí Œì ‚ä¢ T             ‚Üí Œì ‚ä®·µó ∏ T
‚ä¢‚Üí‚ä®·µâÀ£·µñ    : ‚àÄ {Œì e T}    ‚Üí Œì ‚ä¢ e ‚à∂ T         ‚Üí Œì ‚ä®·µâÀ£·µñ e ‚à∂ T
‚ä¢‚Üí‚ä®À¢·µò·µá    : ‚àÄ {Œì œÉ Œî}    ‚Üí Œì ‚ä¢À¢·µò·µá œÉ ‚à∂ Œî      ‚Üí Œì ‚ä®À¢·µò·µá œÉ ‚à∂ Œî
‚ä¢‚Üí‚ä®<‚à∂     : ‚àÄ {Œì S T}    ‚Üí Œì ‚ä¢ S <‚à∂ T        ‚Üí Œì ‚ä® S <‚à∂ T
‚ä¢‚Üí‚ä®‚âà      : ‚àÄ {Œì e e' T} ‚Üí Œì ‚ä¢ e ‚âà e' ‚à∂ T    ‚Üí Œì ‚ä® e ‚âà e' ‚à∂ T
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà   : ‚àÄ {Œì œÉ œÉ' Œî} ‚Üí Œì ‚ä¢À¢·µò·µá œÉ ‚âà œÉ' ‚à∂ Œî ‚Üí Œì ‚ä®À¢·µò·µá‚âà œÉ ‚âà œÉ' ‚à∂ Œî

‚ä¢‚Üí‚ä®·∂ú·µóÀ£ wf‚àÖ = ‚ä®-‚àÖ
‚ä¢‚Üí‚ä®·∂ú·µóÀ£ (wf-,- wfŒì Œì‚ä¢T) with (‚ä¢‚Üí‚ä®·µó ∏  Œì‚ä¢T)
... | ‚ä®ty ‚ä®T = ‚ä®-, ‚ä®T

‚ä¢‚Üí‚ä®·µó ∏ {Œì} {T} (wf-ty {_} {ùìÅ} Œì‚ä¢T‚à∂SetùìÅ) with (‚ä¢‚Üí‚ä®·µâÀ£·µñ Œì‚ä¢T‚à∂SetùìÅ)
... | ‚ä®‚âà (‚ä®ty _) Œì‚ä®T‚à∂SetùìÅ = ‚ä®ty Œì‚ä®T
       where
         Œì‚ä®T : ‚àÄ {œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ T ‚áì œÅ == T ‚áì œÅ' ‚üß·µó ∏
         Œì‚ä®T œÅ==œÅ' with Œì‚ä®T‚à∂SetùìÅ œÅ==œÅ'
         ... | ‚ü¶exp ty-interp eval-c UœâSetùìÅ , ùëá==ùëá'‚ààELœâSetùìÅ ‚üß
               = ‚ü¶ty ‚ü® ùìÅ , (proj‚ÇÅ (ùìîùìµœâ-ùì¢ùìÆùìΩ UœâSetùìÅ)) ùëá==ùëá'‚ààELœâSetùìÅ  ‚ü© ‚üß
```
## Expression and Substitutions Interpretation

A simple solution would be delegating directly to the equalities, via the syntactic
reflexivity rules, like so:

    ‚ä¢‚Üí‚ä®·µâÀ£·µñ Œì‚ä¢e‚à∂T = ‚ä¢‚Üí‚ä®‚âà (‚âàrefl Œì‚ä¢e‚à∂T)

    ‚ä¢‚Üí‚ä®À¢·µò·µá Œì‚ä¢œÉ‚à∂Œî = ‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàrefl Œì‚ä¢œÉ‚à∂Œî)

but that will cause the termination checker to complain, once we proceed
proving `‚ä¢‚Üí‚ä®‚âà`, respectively `‚ä¢‚Üí‚ä®À¢·µò·µá‚âà`, since derivations of `Œì ‚ä¢ e ‚âà e' ‚à∂ T`
may contain expression/substitution typing derivations  `Œì ‚ä¢ e' ‚à∂ T'`. We
try the naive solution first, which is proving these by induction on the
respective derivations. Alternative, we could try a proper induction measure
to keep the simple solution above.
```agda
‚ä¢‚Üí‚ä®·µâÀ£·µñ (TCst {Œì} {c} {T} ‚ä¢Œì c‚ä¢T) with ‚ä¢‚Üí‚ä®·∂ú·µóÀ£ ‚ä¢Œì
... | ‚ä®Œì with c
... | ùëÅ     = {!!}
... | ùëß     = {!!}
... | ùë†     = {!!}
... | ùëÜùëíùë° ùìÅ = {!!}
... | ‚ä§'    = {!!}
... | ‚ä•'    = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (TVar x x‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (T¬∑‚Çõ x Œì‚ä¢e‚à∂T) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (TŒ† Œì‚ä¢e‚à∂T Œì‚ä¢e‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (T∆õ x Œì‚ä¢e‚à∂T) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (T¬∑ Œì‚ä¢e‚à∂T Œì‚ä¢e‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (T‚ü®Type‚ãØ‚ü© Œì‚ä¢e‚à∂T Œì‚ä¢e‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (TType x) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (T‚àôType Œì‚ä¢e‚à∂T Œì‚ä¢e‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®·µâÀ£·µñ (T<‚à∂ Œì‚ä¢e‚à∂T x) = {!!}

‚ä¢‚Üí‚ä®À¢·µò·µá (TId ‚ä¢Œì) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá (T‚Üë Œî‚ä¢T) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá (T‚àòÀ¢ Œì‚ä¢œÑ‚à∂Œî‚ÇÅ Œî‚ÇÅ‚ä¢œÉ‚à∂Œî) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá (T,À¢ Œì‚ä¢œÉ‚à∂Œî Œî‚ä¢T Œì‚ä¢e‚à∂TœÉ) = {!!}


‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂Refl x) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂Lvl x) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂Trans Œì‚ä¢S<‚à∂T Œì‚ä¢S<‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂‚ä§ x) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂‚ä• x) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂Sel‚ÇÅ x) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂Sel‚ÇÇ x) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂‚ü®Type‚ãØ‚ü© Œì‚ä¢S<‚à∂T Œì‚ä¢S<‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®<‚à∂ (<‚à∂Œ† Œì‚ä¢S<‚à∂T Œì‚ä¢S<‚à∂T‚ÇÅ) = {!!}

{-
 Œì ‚ä®·µó ∏ T √ó (‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí
           ‚àÉ[ ùëí ] ‚àÉ[ ùëí' ] ‚àÉ[ R ](ùëí == ùëí' ‚àà R √ó ‚ü¶ e ‚üß œÅ ‚áì ùëí √ó ‚ü¶ e' ‚üß œÅ' ‚áì ùëí' √ó ‚ü¶ T ‚üß·µó ∏ œÅ ‚áì R)) -}

postulate --TODO move and prove
  ‚ä¢·µó ∏‚Üí‚ä¢·∂ú·µóÀ£ : ‚àÄ {Œì T} ‚Üí Œì ‚ä¢ T ‚Üí ‚ä¢·∂ú·µóÀ£ Œì
  ‚ä¢·µâÀ£·µñ‚Üí‚ä¢·µó ∏ : ‚àÄ {Œì e T} ‚Üí Œì ‚ä¢ e ‚à∂ T ‚Üí Œì ‚ä¢ T
  ‚ä¢·µâÀ£·µñ‚Üí‚ä¢·∂ú·µóÀ£ : ‚àÄ {Œì e T} ‚Üí Œì ‚ä¢ e ‚à∂ T ‚Üí ‚ä¢·∂ú·µóÀ£ Œì

‚ä¢‚Üí‚ä®‚âà (‚âàŒ≤¬∑ {Œì} {S} {T} {s} {t} Œì,S‚ä¢t‚à∂T Œì‚ä¢s‚à∂S) with ‚ä¢‚Üí‚ä®·µâÀ£·µñ Œì,S‚ä¢t‚à∂T | ‚ä¢‚Üí‚ä®·µâÀ£·µñ Œì‚ä¢s‚à∂S
... | ‚ä®‚âà (‚ä®ty ‚¶É ‚ä®-, Œì‚ä®S ‚¶Ñ Œì,S‚ä®T) Œì,S‚ä®t‚à∂T
    | ‚ä®‚âà _ Œì‚ä®s‚à∂S = ‚ä®‚âà (‚ä®ty Œì‚ä®T[s]) Œì‚ä®∆õt¬∑s‚âàt[s]‚à∂T[s]
        where
          Œì‚ä®T[s] : ‚àÄ {œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ T ¬∑‚Çõ (Id ,‚Çõ s) ‚áì œÅ == T ¬∑‚Çõ (Id ,‚Çõ s) ‚áì œÅ' ‚üß·µó ∏
          Œì‚ä®T[s] œÅ==œÅ' with Œì‚ä®s‚à∂S œÅ==œÅ'
          ... | ‚ü¶exp S‚áìùì¢ , ùë†==ùë†'‚ààùì¢ ‚üß = {!!}
          -- need to show that [[ Œì , S ]] (œÅ ,, ùë†) (œÅ' ,, ùë†')
          -- apply to Œì,S‚ä®T
          -- this should yield all evidence for ‚ü¶ T [ s ] ‚áì œÅ == T [ s ] ‚áì œÅ' ‚üß·µó ∏
          Œì‚ä®∆õt¬∑s‚âàt[s]‚à∂T[s] : ‚àÄ{œÅ œÅ'} ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ' ‚Üí ‚ü¶ ∆õ t ¬∑ s ‚áì œÅ == t ¬∑‚Çõ (Id ,‚Çõ s) ‚áì œÅ' ‚àà T ¬∑‚Çõ (Id ,‚Çõ s) ‚üß·µâÀ£·µñ
          Œì‚ä®∆õt¬∑s‚âàt[s]‚à∂T[s] œÅ==œÅ' with Œì‚ä®s‚à∂S œÅ==œÅ'
          ... | ‚ü¶exp S‚áìùì¢ , ùë†==ùë†'‚ààùì¢ ‚üß  = {!!}
          -- similarly, show that [[ Œì , S ]] (œÅ ,, ùë†) (œÅ' ,, ùë†')
          -- apply to Œì,S‚ä®t‚à∂T and  Œì,S‚ä®T
          -- this should yield all evidence for ‚ü¶ ∆õ t ¬∑ s ‚áì œÅ == t [ s ] ‚áì œÅ' ‚àà T [ s ] ‚üß·µâÀ£·µñ
          -- as both ∆õ t ¬∑ s ‚áì œÅ and  t [ s ] ‚áì œÅ' stem from t ‚áì (œÅ ,, ùë†) and t ‚áì (œÅ' ,, ùë†'), respectively
          -- and the relation R w. ‚ü¶ T [ s ] ‚üß œÅ ‚áì R stems from ‚ü¶ T ‚üß (œÅ ,, ùë†) ‚áì R

--‚ä®Œì,S , œÅ==œÅ'‚Üít‚áìœÅ==t‚áìœÅ'‚àà‚ü¶T‚üß ‚ü© , œÅ==œÅ'‚ÜíT‚áìœÅ==T‚áìœÅ' ‚ü© = ‚ü® {!!} , {!!} ‚ü©
‚ä¢‚Üí‚ä®‚âà (‚âàŒ≤‚àôType x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàŒæ∆õ Œì‚ä¢e‚âàe'‚à∂T) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàŒ∑∆õ x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàŒ∑‚àôType x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà‚ôØ x x‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà·∂ú x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà‚à∂[‚Ñí‚â§] x Œì‚ä¢e‚âàe'‚à∂T) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà‚à∂[‚âà] Œì‚ä¢e‚âàe'‚à∂T Œì‚ä¢e‚âàe'‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà[Œ†] Œì‚ä¢e‚âàe'‚à∂T Œì‚ä¢e‚âàe'‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà[¬∑] Œì‚ä¢e‚âàe'‚à∂T Œì‚ä¢e‚âàe'‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà[À¢·µò·µá] x Œì‚ä¢e‚âàe'‚à∂T) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà[‚ü®Type‚ãØ‚ü©] Œì‚ä¢e‚âàe'‚à∂T Œì‚ä¢e‚âàe'‚à∂T‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà[Type] Œì‚ä¢e‚âàe'‚à∂T) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âà[‚àôType] x Œì‚ä¢e‚âàe'‚à∂T) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá‚Üë x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µáId x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá,‚Çõ-0 x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá,‚Çõ-suc x x‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá‚àò‚Çõ x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá·∂ú x x‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µáŒ† x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá∆õ x x‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá¬∑ x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá‚ü®Type‚ãØ‚ü© x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µáType x x‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàÀ¢·µò·µá‚àôType x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàrefl x) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàsym Œì‚ä¢e‚âàe'‚à∂T) = {!!}
‚ä¢‚Üí‚ä®‚âà (‚âàtrans Œì‚ä¢e‚âàe'‚à∂T Œì‚ä¢e‚âàe'‚à∂T‚ÇÅ) = {!!}

‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàrefl x) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàsym Œì‚ä¢œÉ‚âàœÉ'‚à∂Œî) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàtrans Œì‚ä¢œÉ‚âàœÉ'‚à∂Œî Œì‚ä¢œÉ‚âàœÉ'‚à∂Œî‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âà‚Üë x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàId‚Çó x) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàId·µ£ x) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âà‚àò‚Çõassoc x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàŒ∑ x) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âàŒ≤ x x‚ÇÅ x‚ÇÇ) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âà[,‚Çõ] Œì‚ä¢œÉ‚âàœÉ'‚à∂Œî x x‚ÇÅ) = {!!}
‚ä¢‚Üí‚ä®À¢·µò·µá‚âà (sub‚âà[‚àòÀ¢] Œì‚ä¢œÉ‚âàœÉ'‚à∂Œî Œì‚ä¢œÉ‚âàœÉ'‚à∂Œî‚ÇÅ) = {!!}
```
# Typed Candidate Spaces
```agda
-- TODO probably separate module
```
# Escape Lemma
```agda
-- TODO
```
# Completeness
```agda
-- TODO: this'll require proving the Set -> U lemmas in Universes, which are commented out
‚ü¶-‚üß·∂ú·µóÀ£-refl : ‚àÄ {Œì œÅ} ‚Üí ‚ä¢·∂ú·µóÀ£ Œì ‚Üí ‚Üë Œì ‚áì œÅ ‚Üí ‚ü¶ Œì ‚üß·∂ú·µóÀ£ œÅ œÅ
‚ü¶-‚üß·∂ú·µóÀ£-refl = {!!}
-- ‚ü¶-‚üß·∂ú·µóÀ£-refl _ lift-‚àÖ = ‚ü¶-‚üß·∂ú·µóÀ£-‚àÖ
-- ‚ü¶-‚üß·∂ú·µóÀ£-refl (wf-,- wfG Œì‚ä¢T) (lift-, liftG x) with ‚ä¢‚Üí‚ä®·µó ∏ Œì‚ä¢T
-- ... | ‚ü® fst , rel ‚ü© with ‚ü¶-‚üß·∂ú·µóÀ£-refl wfG liftG
-- ... | IH with rel IH
-- ... | ‚ü® ùëá , ‚ü® ùëá' , ‚ü® ‚ü® ùìÄ , snd ‚ü© , ‚ü® fst‚ÇÑ , snd‚ÇÅ ‚ü© ‚ü© ‚ü© ‚ü© = ‚ü¶-‚üß·∂ú·µóÀ£-, IH {!!} {!!}


completeness : ‚àÄ {Œì e e' T} ‚Üí Œì ‚ä¢ e ‚âà e' ‚à∂ T ‚Üí ‚àÉ[ n ] (nf e ‚áì‚ü® Œì , T ‚ü© n √ó nf e' ‚áì‚ü® Œì , T ‚ü© n)
completeness = {!!}
```
# Corollary: Strong Normalization (SN)

SN is a special case of completeness:

```agda
strong-normalization : ‚àÄ {Œì e T} ‚Üí Œì ‚ä¢ e ‚à∂ T ‚Üí ‚àÉ[ n ] (nf e ‚áì‚ü® Œì , T ‚ü© n)
strong-normalization Œì‚ä¢e‚à∂T with completeness (‚âàrefl Œì‚ä¢e‚à∂T)
... | ‚ü® n , ‚ü® eval , _ ‚ü© ‚ü© = ‚ü® n , eval ‚ü©
```

# TODOs
* determinize the nbe functions, prove their irrelevance and determinism properties
* subtyping interp cf. Abel'17
* prove the cases of fundamental lemma
* typed candidate spaces
* prove escape lemma
* make the syntax well-scoped?
